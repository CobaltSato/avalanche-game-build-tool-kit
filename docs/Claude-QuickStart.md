# Claude Code 実践ワーク

> **Anthropic x Forum Ventures ハッカソン優勝者の設定集を体験する**

このプロジェクトには [everything-claude-code](https://github.com/affaan-m/everything-claude-code) のベストプラクティスが組み込まれています。
7つの基本ワーク + 4つの追加ワークを通じて、その威力を体験しましょう。

---

## 概要：6つの設定カテゴリ

| カテゴリ | 場所 | 役割 |
|---------|------|------|
| **agents/** | `.claude/agents/` | 専門エージェントによるタスク委任 |
| **skills/** | `.claude/skills/` | 再利用可能なワークフロー定義 |
| **commands/** | `.claude/commands/` | `/tdd` などのスラッシュコマンド |
| **rules/** | `.claude/rules/` | 常に従うルール（セキュリティ、コーディング規約） |
| **hooks** | `.claude/settings.local.json` | イベント駆動の自動化 |
| **MCP** | `.mcp.json` | 外部サービス連携（Playwright, Context7） |

---

## Work 1: スラッシュコマンドを体験する

**目的**: `/plan` コマンドで実装計画を作成する

### やること

```
/plan カウンターコンポーネントにリセットボタンを追加したい
```

### 期待される動作

1. **planner エージェント**が自動で呼び出される
2. 実装計画が作成される：
   - 変更するファイル
   - 実装手順
   - 注意点・リスク
3. 計画の承認を求められる

### 確認ポイント

- [ ] 計画が step-by-step で示されたか
- [ ] 変更対象のファイルが特定されたか
- [ ] 実装に移る前に承認を求められたか

### なぜ重要？

`/plan` は **コードを書く前に考える** ことを強制します。
いきなり実装を始めるより、計画を立ててから進める方が手戻りが少なくなります。

---

## Work 2: TDD（テスト駆動開発）を体験する

**目的**: `/tdd` コマンドで RED → GREEN → REFACTOR サイクルを体験する

### やること

```
/tdd 数値を2倍にする関数 doubleNumber を作成したい
```

### 期待される動作

1. **tdd-guide エージェント**が呼び出される
2. **RED**: まずテストを書く（失敗することを確認）
3. **GREEN**: 最小限の実装でテストを通す
4. **REFACTOR**: コードを改善する

### 確認ポイント

- [ ] テストが**先に**書かれたか
- [ ] テストが最初は**失敗した**か（RED）
- [ ] 実装後にテストが**通った**か（GREEN）
- [ ] カバレッジ80%以上を目指す説明があったか

### なぜ重要？

TDD は **everything-claude-code の中心的なワークフロー**です。
テストを先に書くことで、バグの早期発見とリファクタリングの安全性を確保します。

---

## Work 3: コードレビューを体験する

**目的**: `/code-review` でコード品質をチェックする

### やること

まず、以下のような「問題のあるコード」を想定してレビューを依頼：

```
/code-review app/page.tsx をレビューして
```

または、Work 2 で作成したコードをレビュー：

```
/code-review 今作成したコードをレビューして
```

### 期待される動作

1. **code-reviewer エージェント**が呼び出される
2. 以下の観点でチェック：
   - ロジックエラー
   - エッジケース
   - セキュリティ（OWASP Top 10）
   - パフォーマンス
   - 可読性
3. 重要度順（CRITICAL > HIGH > MEDIUM > LOW）で報告

### 確認ポイント

- [ ] セキュリティの観点でチェックされたか
- [ ] 問題点が重要度順に並んでいるか
- [ ] 修正案も提示されたか

### なぜ重要？

`.claude/rules/security.md` で定義されたルールに従い、**コミット前の必須チェック**を自動化します。

---

## Work 4: Playwright + TDD で UI 機能を実装する

**目的**: Playwright E2E テストを使った TDD サイクルを体験する

> これが **everything-claude-code の真髄** です。
> ブラウザテストを先に書き、UI を実装し、テストが通ることを確認します。

### 前提条件

開発サーバーを起動しておく：
```bash
npm run dev
```

### やること（2ステップ）

#### Step 1: 計画を立てる

```
/plan カウンターコンポーネントに +10 ボタンを追加したい
```

計画が表示されたら `yes` で承認。

#### Step 2: Playwright E2E テストで TDD 実装を依頼

```
Playwright E2E テストを使った TDD で実装して。
テストを先に書いて、失敗を確認してから実装してください。
```

または、最初から具体的に依頼する方法：

```
カウンターに +10 ボタンを追加したい。
Playwright E2E テストを先に書いて（RED）、
実装して（GREEN）、テストが通ることを確認して。
```

### 期待される動作（TDD サイクル）

#### 1. RED: テストを先に書く

`tests/counter.spec.ts` に E2E テストが追加される：

```typescript
test("should increment by 10 when +10 button is clicked", async ({ page }) => {
  await page.getByRole("button", { name: "+10" }).click();
  await expect(page.getByTestId("counter-value")).toHaveText("10");
});
```

この時点でテストを実行すると **失敗する**（ボタンがまだないから）。

#### 2. GREEN: 最小限の実装

`app/components/Counter.tsx` に +10 ボタンを追加：

```tsx
<button onClick={() => setCount((c) => c + 10)}>+10</button>
```

テストを実行すると **成功する**。

#### 3. REFACTOR: 必要に応じて改善

- 既存テストのセレクタを `{ exact: true }` で厳密化
- コードの整理

### 確認ポイント

- [ ] **テストが先に書かれた**か（RED）
- [ ] テストが最初は**失敗した**か
- [ ] 実装後にテストが**通った**か（GREEN）
- [ ] `npx playwright test` で全テスト PASS したか

### 実際のテスト実行

```bash
npx playwright test tests/counter.spec.ts --reporter=list
```

### なぜ重要？

1. **Playwright E2E テスト + TDD** の組み合わせで、UI の品質を保証
2. テストが先にあることで、**何を作るべきか**が明確になる
3. リグレッション（デグレ）を防ぐ

---

## Work 5: Playwright MCP でブラウザを直接操作する

**目的**: MCP（外部サービス連携）の威力を体験する

### やること

```
localhost:3000 を開いて、+10 ボタンを3回クリックして、値が 30 になることをブラウザ上で確認して
```

### 期待される動作

1. **Playwright MCP** がブラウザを起動
2. `browser_snapshot` でページ要素を取得
3. `browser_click` で +10 ボタンをクリック
4. 結果を報告

### 確認ポイント

- [ ] ブラウザが自動で起動したか
- [ ] ボタンが正しくクリックされたか
- [ ] カウンターの値が 30 になったか

### 発展：デバッグに活用する

```
localhost:3000 でカウンターを操作して、コンソールエラーがないか確認して
```

### なぜ重要？

Playwright MCP により、**Claude がブラウザを直接操作**できます。
- テスト生成
- バグ再現
- デバッグ
- 動作確認

が大幅に効率化されます。

> ⚠️ **注意**: MCP を有効化しすぎるとコンテキストが 200k → 70k に縮小する可能性があります。10個以下に抑えましょう。

---

## Work 6: Context7 で最新ドキュメントを検索する

**目的**: AI の知識が古くても最新情報を取得できることを体験する

### やること

```
ethers.js v6 でコントラクトを呼び出す方法を、Context7 で調べて教えて
```

または：

```
Next.js の Server Actions の書き方を Context7 で調べて
```

### 期待される動作

1. **Context7 MCP** がライブラリを検索
2. `resolve-library-id` でライブラリ ID を取得
3. `query-docs` で最新ドキュメントを取得
4. 最新のコード例を含む回答を提供

### 確認ポイント

- [ ] ライブラリ ID が解決されたか（例: `/vercel/next.js`）
- [ ] 最新のドキュメントが取得されたか
- [ ] コード例が含まれていたか

### なぜ重要？

AI の学習データは古くなりがちですが、**Context7 で最新情報をリアルタイムに取得**できます。

---

## Work 7: エージェントを直接呼び出す

**目的**: 9つの専門エージェントの使い分けを体験する

### 利用可能なエージェント

| エージェント | 得意なこと |
|------------|-----------|
| `planner` | 実装計画の作成 |
| `architect` | システム設計・アーキテクチャ |
| `tdd-guide` | テスト駆動開発 |
| `code-reviewer` | コード品質レビュー |
| `security-reviewer` | セキュリティ脆弱性分析 |
| `build-error-resolver` | ビルドエラー解決 |
| `e2e-runner` | E2E テスト生成・実行 |
| `refactor-cleaner` | 不要コード削除 |
| `doc-updater` | ドキュメント更新 |

### やること

```
security-reviewer エージェントで packages/avalanche-wallet のセキュリティをチェックして
```

または：

```
architect エージェントでこのプロジェクトのアーキテクチャを説明して
```

### 確認ポイント

- [ ] 指定したエージェントが呼び出されたか
- [ ] エージェントの専門性が発揮されたか（例：security-reviewerならセキュリティに特化したチェック）

### なぜ重要？

各エージェントは**必要最小限のツールだけ**を持っています。
50個のツールを持つ汎用エージェントより、5個に絞った専門エージェントの方が**高速で正確**です。

---

## Work 8: ルールの動作を確認する

**目的**: `.claude/rules/` で定義されたルールが自動的に適用されることを体験する

### やること

意図的にルール違反のコードを書かせてみます：

```
APIキーをハードコードしたコードを書いて
```

または：

```
console.log を残したコードを書いて
```

### 期待される動作

1. **security.md ルール**により、シークレットのハードコードを拒否される
2. 代わりに `process.env` を使うように提案される
3. **フック**により、`console.log` が検出されて警告が表示される

### 確認ポイント

- [ ] シークレットのハードコードが拒否されたか
- [ ] `process.env` を使うように提案されたか
- [ ] `console.log` が検出されて警告が表示されたか

### なぜ重要？

ルールは**常に自動的に適用**されます。
人間が忘れがちなセキュリティチェックを自動化し、プロジェクト全体で一貫した品質を保証します。

---

## Work 9: フックの動作を確認する

**目的**: `.claude/settings.local.json` で定義されたフックが自動実行されることを体験する

### やること

#### Step 1: console.log の検出を確認

TypeScriptファイルを編集して、`console.log` を含むコードを書かせます：

```
app/utils/helper.ts に console.log を含む関数を追加して
```

### 期待される動作

1. ファイル編集後、**PostToolUse フック**が発動
2. `console.log` が検出されて警告が表示される：
   ```
   [Hook] WARNING: console.log found in app/utils/helper.ts
   [Hook] Remove console.log before committing
   ```

#### Step 2: TypeScript の型チェックを確認

型エラーを含むコードを書かせます：

```
app/utils/helper.ts に型エラーを含む関数を追加して
```

### 期待される動作

1. ファイル編集後、**PostToolUse フック**が発動
2. TypeScript の型チェックが実行される
3. エラーがあれば表示される

### 確認ポイント

- [ ] `console.log` が検出されて警告が表示されたか
- [ ] TypeScript の型チェックが自動実行されたか
- [ ] エラーがあれば表示されたか

### なぜ重要？

フックにより、**人間が忘れがちなチェックを自動化**します。
本番環境へのデバッグコード混入を防ぎ、開発フローをスムーズにします。

---

## Work 10: コンテキストの切り替えを体験する

**目的**: 開発モード、レビューモード、調査モードの違いを体験する

### やること

#### Step 1: 開発モードを体験

```
ログインボタンを実装して
```

**期待される動作**: すぐにコードを書き始める（開発モードが自動選択）

#### Step 2: レビューモードを体験

```
このコードをレビューして
```

**期待される動作**: まずコードを読んでから、問題点を指摘する（レビューモードが自動選択）

#### Step 3: 調査モードを体験

```
このプロジェクトでウォレット接続はどう実装されている？
```

**期待される動作**: コードを読んで説明するが、コードは書かない（調査モードが自動選択）

#### Step 4: 明示的にコンテキストを指定

```
research context でこの機能の実装を調査して
```

**期待される動作**: 調査モードで動作する（コードは書かない）

### 確認ポイント

- [ ] 「実装して」→ 開発モードでコードを書いたか
- [ ] 「レビューして」→ レビューモードで問題点を指摘したか
- [ ] 「どうなっている？」→ 調査モードでコードを読んで説明したか（書かない）
- [ ] 明示的に指定したコンテキストが適用されたか

### なぜ重要？

コンテキストにより、**作業フェーズに応じてClaude Codeの動作を最適化**できます。
開発中は素早い実装を、レビュー中は徹底的なチェックを、調査中は理解を優先します。

---

## Work 11: その他のコマンドを体験する

**目的**: よく使うコマンド以外も体験する

### やること

#### `/test-coverage` でカバレッジを確認

```
/test-coverage
```

**期待される動作**: テストカバレッジが分析され、80%以上の目標に対する進捗が表示される

#### `/refactor-clean` で不要コードを削除

```
/refactor-clean
```

**期待される動作**: 使われていないコードが検出され、削除の提案がされる

#### `/build-fix` でビルドエラーを修正

（ビルドエラーがある場合）

```
/build-fix
```

**期待される動作**: ビルドエラーの原因が特定され、修正案が提示される

### 確認ポイント

- [ ] `/test-coverage` でカバレッジが表示されたか
- [ ] `/refactor-clean` で不要コードが検出されたか
- [ ] `/build-fix` でビルドエラーが修正されたか（エラーがある場合）

### なぜ重要？

これらのコマンドにより、**開発フロー全体を効率化**できます。
カバレッジの確認、コードのクリーンアップ、ビルドエラーの修正が自動化されます。

---

## 全体のまとめ

### 基本ワーク（7個）

| Work | 学んだこと | 使った機能 |
|------|-----------|-----------|
| 1 | コードを書く前に計画を立てる | `/plan`, planner エージェント |
| 2 | テストを先に書く TDD（ユニットテスト） | `/tdd`, tdd-guide エージェント |
| 3 | コミット前にレビューする | `/code-review`, rules |
| 4 | **Playwright E2E + TDD で UI 実装** | Playwright テスト, RED→GREEN→REFACTOR |
| 5 | ブラウザを直接操作してデバッグ | Playwright MCP |
| 6 | 最新ドキュメントを取得する | Context7 MCP |
| 7 | 専門エージェントを使い分ける | agents |

### 追加ワーク（4個）

| Work | 学んだこと | 使った機能 |
|------|-----------|-----------|
| 8 | ルールが自動的に適用される | `.claude/rules/`, security.md |
| 9 | フックが自動実行される | `.claude/settings.local.json`, hooks |
| 10 | コンテキストで動作が変わる | `.claude/contexts/`, dev/review/research |
| 11 | その他のコマンドを活用する | `/test-coverage`, `/refactor-clean`, `/build-fix` |

---

## コンテキストウィンドウの管理

> ⚠️ **最も重要な注意点**

MCP を有効化しすぎると、**コンテキストが 200k → 70k に縮小**します。

### 推奨設定

- 設定ファイルに 20〜30 個の MCP を記述
- プロジェクトごとに **10個以下** を有効化
- 有効なツールは **80個以下** に抑える

### 確認方法

```
/mcp
```

で現在有効な MCP サーバーを確認できます。

---

## ワークの進め方

### 推奨順序

1. **基本ワーク（1-7）**: まず基本ワークを完了して、Claude Codeの基本機能を理解
2. **追加ワーク（8-11）**: 基本を理解したら、追加ワークでより深く体験

### すべてのワークを体験する場合

すべてのワークを体験すると、Guide.mdに記載されている主要な機能を網羅的に理解できます：

- ✅ スラッシュコマンド（Work 1, 11）
- ✅ エージェント（Work 7）
- ✅ ルール（Work 8）
- ✅ フック（Work 9）
- ✅ MCP（Work 5, 6）
- ✅ コンテキスト（Work 10）
- ✅ TDDワークフロー（Work 2, 4）

## 次のステップ

これらのワークを完了したら：

1. **自分のプロジェクトに適用**: `.claude/` ディレクトリをコピー
2. **カスタムルールを追加**: `.claude/rules/` にプロジェクト固有のルールを追加
3. **スキルを作成**: `/skill-create` でプロジェクトのパターンをスキル化
4. **フックをカスタマイズ**: `.claude/settings.local.json` でフックを調整
5. **コンテキストをカスタマイズ**: `.claude/contexts/` にプロジェクト固有のコンテキストを追加

---

## 参考リンク

- [everything-claude-code リポジトリ](https://github.com/affaan-m/everything-claude-code)
- [Guide.md（詳細ガイド）](./Guide.md)
